#include  <stdio.h>

int main() {

     // 모든 변수는 기본적으로 값을 새로 쓰기 전까지는 유지한다.
     // volatile (휘발성) 하지 않다는 의미
     // 기본이다~~. 이게 지켜지지 않으면. 모든게 문제된다.
     int non_volatile_var = 3;

     int a = non_volatile_var; // 복사, RAM to RAM 이동..
     a = a + 7 ; // 연산.. 블라블라.. 다양한 연산들이 수행됨.

     // 그런데.. 만약 non_volatile_var이란 값이 유지된다면
     // 굳이 3을 non_volatile_var을 위한 메모리 할당할필요도 없고
     //  그영역에 3을 옮길 필요도 없고
     //  다시 읽어서 7과 더할 필요도 없고
     //  결론적으로 a는 10이라고 생각해도 전혀 문제 없다.
     printf("a is %d\n", a);

     // 그런데... 만약..~~~~
     // 어떤 메모리의 한 영역 (메모리 또는 HW영역). 
     // 새로운 값을 overwrite.하지 않아도 스스로 값이 변한다면..
     // 우리는 그 영역의 값을 어떤 하나의 값으로 단정지을 수 없다.

     // 따라서 최적화를 하게 되면, 문제가 된다..
     // 그러면 최적화를 막으면 해결될수 있으나, 이건 너무 손해가 크다.
     // 
     // 그래서 C언어에서는 다음과 같은 키워드 volatile.을 제공
     // 즉 volatile로 지졍된 메모리 영역은, 스스로 값이 바뀔수 있음을 표시
     // 그렇다면 컴파일러 최적화 단계에서, 이부분을 명시적으로..
     // 메모리에 반드시 접근해서 읽어보도록 강제하게 된다. (최적화 off)
     volatile int volatile_var = 3;

     int b = volatile_var; // 복사, RAM to RAM 이동..
     b = b + 7 ; // 연산.. 블라블라.. 다양한 연산들이 수행됨.
     printf("b is %d\n", b);

     return 0;
}

